"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[4660],{4137:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>k});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),p=d(t),k=l,m=p["".concat(s,".").concat(k)]||p[k]||c[k]||i;return t?a.createElement(m,o(o({ref:n},u),{},{components:t})):a.createElement(m,o({ref:n},u))}));function k(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,o=new Array(i);o[0]=p;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var d=2;d<i;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7833:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=t(7462),l=(t(7294),t(4137));const i={title:"VEP-1155: Multi-Token"},o=void 0,r={unversionedId:"standards/VEP/vep-1155",id:"standards/VEP/vep-1155",title:"VEP-1155: Multi-Token",description:"Abstract",source:"@site/docs/standards/VEP/vep-1155.md",sourceDirName:"standards/VEP",slug:"/standards/VEP/vep-1155",permalink:"/standards/VEP/vep-1155",draft:!1,tags:[],version:"current",frontMatter:{title:"VEP-1155: Multi-Token"},sidebar:"standardSidebar",previous:{title:"VEP-1: VEP Purpose and Guidelines",permalink:"/standards/VEP/vep-1"},next:{title:"VEP-2981: NFT Royalty",permalink:"/standards/VEP/vep-2981"}},s={},d=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Specification",id:"specification",level:2},{value:"Contracts",id:"contracts",level:3},{value:"Collection",id:"collection",level:3},{value:"IMultiTokenCollection.multiTokenWalletCode()",id:"imultitokencollectionmultitokenwalletcode",level:4},{value:"IMultiTokenCollection.multiTokenCodeHash()",id:"imultitokencollectionmultitokencodehash",level:4},{value:"IMultiTokenCollection.tokenAddress()",id:"imultitokencollectiontokenaddress",level:4},{value:"Events",id:"events",level:4},{value:"Mint and burn NFT and MultiTokens",id:"mint-and-burn-nft-and-multitokens",level:4},{value:"NFT",id:"nft",level:3},{value:"IMultiTokenNft.multiTokenSupply()",id:"imultitokennftmultitokensupply",level:4},{value:"MultiToken Wallet",id:"multitoken-wallet",level:3},{value:"IMultiTokenWallet.getInfo()",id:"imultitokenwalletgetinfo",level:4},{value:"IMultiTokenWallet.balance()",id:"imultitokenwalletbalance",level:4},{value:"IMultiTokenWallet.transfer()",id:"imultitokenwallettransfer",level:4},{value:"IMultiTokenWallet.transferToWallet()",id:"imultitokenwallettransfertowallet",level:4},{value:"IMultiTokenWallet.burn()",id:"imultitokenwalletburn",level:4},{value:"Events",id:"events-1",level:4},{value:"Mint MultiTokenWallet",id:"mint-multitokenwallet",level:4},{value:"Callbacks",id:"callbacks",level:3},{value:"Mint callback",id:"mint-callback",level:4},{value:"Incoming transfer callback",id:"incoming-transfer-callback",level:4},{value:"Bounced transfer callback",id:"bounced-transfer-callback",level:3},{value:"Burn callback",id:"burn-callback",level:4},{value:"IDestroyable",id:"idestroyable",level:4},{value:"Rationale",id:"rationale",level:2},{value:"Metadata Choices",id:"metadata-choices",level:3},{value:"MultiTokenWallet destroy",id:"multitokenwallet-destroy",level:3},{value:"Reuse interface from TIP-4.3",id:"reuse-interface-from-tip-43",level:3},{value:"Indexes",id:"indexes",level:3},{value:"Visualization",id:"visualization",level:2},{value:"Legend",id:"legend",level:3},{value:"Example 1: Put on sell by TIP-3 tokens",id:"example-1-put-on-sell-by-tip-3-tokens",level:3},{value:"Example 2: Buy by TIP-3 tokens",id:"example-2-buy-by-tip-3-tokens",level:3},{value:"Backwards compatibility",id:"backwards-compatibility",level:2},{value:"Security considerations",id:"security-considerations",level:2},{value:"Copyright",id:"copyright",level:2},{value:"References",id:"references",level:2}],u={toc:d};function c(e){let{components:n,...i}=e;return(0,l.kt)("wrapper",(0,a.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-preamble"},"VEP: 1155\nauthor: Evgeny Shatalov <evgeny.a.shatalov@gmail.com>, Aleksei Kolchanov <a.kolchanov@numi.net>, Aleksandr Khramtsov <aleksandr.hramcov@gmail.com>\nstatus: Review\ntype: Contract\ncreated: 2023-03-08\nrequires: TIP-3, TIP-4.1, TIP-4.2, TIP-4.3, TIP-6\n")),(0,l.kt)("h2",{id:"abstract"},"Abstract"),(0,l.kt)("p",null,"The following standard describes the basic idea about distributed Multi-Token architecture.\nThis standard provides basic functionality to create, track and transfer both fungible and non-fungible tokens in a collection."),(0,l.kt)("h2",{id:"motivation"},"Motivation"),(0,l.kt)("p",null,"The suggested standard differs considerably from ","[Ethereum ERC-1155]"," and other smart contract token standards with single registry because of its distributed nature related to Venom blockchain particularities. Given that Venom has a storage fee, VEP-1155 is fully distributed and implies separate storage of each fungible and non-fungible tokens.\nA standard interface allows any fungible and non-fungible tokens to be re-used by other applications: wallets, explorers, marketplaces, etc."),(0,l.kt)("h2",{id:"architecture"},"Architecture"),(0,l.kt)("p",null,"General information about tokens collection is stored in the collection contract. Each non-fungible token (NFT) deployed in separate smart contracts and links to token collection. Each token with supply count more than one deployed in separate MultiToken smart contracts and links to collection. Each MultiToken holder has their own instance of a specific contract. MultiToken transfers SHOULD be implemented in P2P fashion, between sender and receiver."),(0,l.kt)("p",null,"In general Smart contract architecture based on:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Consider an asynchronous type of Venom blockchain. Use callbacks and asynchronous getters."),(0,l.kt)("li",{parentName:"ul"},"Standardizes one NFT - one smart contract."),(0,l.kt)("li",{parentName:"ul"},"Gas fee management practicals."),(0,l.kt)("li",{parentName:"ul"},"Use ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-3/core-description"},"TIP-3")," architecture for MultiTokens."),(0,l.kt)("li",{parentName:"ul"},"Use ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1"},"TIP-4.1")," architecture and interfaces for non-fungible tokens."),(0,l.kt)("li",{parentName:"ul"},"Use ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/2"},"TIP-4.2")," and ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," architecture and interfaces for all tokens."),(0,l.kt)("li",{parentName:"ul"},"Use ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-6/1"},"TIP-6.1"))),(0,l.kt)("h2",{id:"specification"},"Specification"),(0,l.kt)("p",null,"The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in ",(0,l.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc2119"},"RFC 2119"),"."),(0,l.kt)("h3",{id:"contracts"},"Contracts"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Collection")," - contract that mints tokens."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"NFT")," - ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1"},"TIP-4.1")," and ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/2"},"TIP-4.2")," contract that stores token information and tokenSupply."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"MultiTokenWallet")," - ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-3/core-description"},"TIP-3")," like and ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," compliant constract stores the balance. Each MultiToken holder has its own instance of MultiToken wallet contract."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"IndexBasis")," - ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," contract, that helps to find all collections by the code hash of which."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Index")," - ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," contract, that helps to find:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"All user tokens in current collection using owner address and collection address."),(0,l.kt)("li",{parentName:"ul"},"All user tokens in all collections using the owner address."),(0,l.kt)("li",{parentName:"ul"},"All tokens with a ",(0,l.kt)("inlineCode",{parentName:"li"},"tokenId")," must have a corresponding nft with the same ",(0,l.kt)("inlineCode",{parentName:"li"},"nftId"),". Where ",(0,l.kt)("inlineCode",{parentName:"li"},"nftId")," == ",(0,l.kt)("inlineCode",{parentName:"li"},"tokenId"),".")))),(0,l.kt)("p",null,"code of ",(0,l.kt)("inlineCode",{parentName:"p"},"IndexBasis")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Index")," contracts and code hash of contracts is fixed and ",(0,l.kt)("strong",{parentName:"p"},"CANNOT BE CHANGED")),(0,l.kt)("h3",{id:"collection"},"Collection"),(0,l.kt)("p",null,"The contract represents shared information about tokens collection and logic for creation of tokens and burn of NFTs."),(0,l.kt)("p",null,"Every VEP-1155 compliant collection contract must implement ",(0,l.kt)("inlineCode",{parentName:"p"},"IMultiTokenCollection")," interface in addtion to ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1/#collection"},"TIP4_1Collection")," and ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-6/1"},"TIP-6.1"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma ton-solidity >= 0.58.0;\n\ninterface IMultiTokenCollection {\n\n    /// @notice This event emits when MulitToken is created\n    /// @param id Unique Nft id\n    /// @param token Address of MultiToken wallet contract\n    /// @param owner Address of MultiToken wallet owner\n    /// @param balance count of minted tokens\n    /// @param creator Address of creator that initialize mint\n    event MultiTokenCreated(uint256 id, address token, uint128 balance, address owner, address creator);\n\n    /// @notice This event emits when MultiTokens are burned\n    /// @param id Unique Nft id\n    /// @param count Number of burned tokens\n    /// @param owner Address of MultiToken wallet owner\n    event MultiTokenBurned(uint256 id, uint128 count, address owner);        \n\n    /// @notice Returns the MultiToken wallet code\n    /// @return code Returns the MultiToken wallet code as TvmCell\n    function multiTokenWalletCode(uint256 id, bool isEmpty) external view responsible returns (TvmCell code);\n\n    /// @notice Returns the MultiToken wallet code hash\n    /// @return codeHash Returns the MultiToken wallet code hash\n    function multiTokenCodeHash(uint256 id, bool isEmpty) external view responsible returns (uint256 codeHash);\n\n    /// @notice Computes MultiToken wallet address by unique MultiToken id and its owner\n    /// @dev Return unique address for all Ids and owners. You find nothing by address for not a valid MultiToken wallet\n    /// @param id Unique MultiToken id\n    /// @param owner Address of MultiToken owner\n    /// @return token Returns the address of MultiToken wallet contract\n    function multiTokenWalletAddress(uint256 id, address owner) external view responsible returns (address token);\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NOTE")," The ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-6/1"},"TIP-6.1")," identifier for this interface is ",(0,l.kt)("inlineCode",{parentName:"p"},"0x5C435318"),"."),(0,l.kt)("h4",{id:"imultitokencollectionmultitokenwalletcode"},"IMultiTokenCollection.multiTokenWalletCode()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function multiTokenWalletCode(uint256 id, bool isEmpty) external view responsible returns (TvmCell code);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - Unique Nft id"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"isEmpty")," (",(0,l.kt)("inlineCode",{parentName:"li"},"bool"),") - Balance empty flag"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"code")," (",(0,l.kt)("inlineCode",{parentName:"li"},"TvmCell"),") - MultiToken contract code")),(0,l.kt)("p",null,"MultiToken wallet is a smart contract deployed from collection smart contract using tokenCode, id and owner address.\nMultiToken wallet code must be salted by collection address, the nft id, and isEmpty flag that marks if the wallet has a balance of zero."),(0,l.kt)("h4",{id:"imultitokencollectionmultitokencodehash"},"IMultiTokenCollection.multiTokenCodeHash()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function multiTokenCodeHash(uint256 id, bool isEmpty) public view responsible returns (uint256 codeHash);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - Unique Nft id"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"isEmpty")," (",(0,l.kt)("inlineCode",{parentName:"li"},"bool"),") - Balance empty flag"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"codeHash")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - MultiToken wallet contract code hash")),(0,l.kt)("p",null,"The codeHash allows search of all empty or non-empty MultiToken wallet contracts of this collection for the corresponding nft using base dApp functionality."),(0,l.kt)("h4",{id:"imultitokencollectiontokenaddress"},"IMultiTokenCollection.tokenAddress()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function multiTokenWalletAddress(uint256 id, address owner) external view responsible returns (address token);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - Unique Nft id"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"owner")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Address of MultiToken wallet owner")),(0,l.kt)("p",null,"Computes MultiToken wallet contract address by unique Nft id and its owner. You can check number of owned MultiTokens using base dApp functionality."),(0,l.kt)("h4",{id:"events"},"Events"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    event MultiTokenCreated(uint256 id, address token, address owner, address creator);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - Unique Nft id"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"token")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Address of MultiToken wallet contract"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"balance")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - Initial balance"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"owner")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Address of MultiToken owner"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"creator")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - The initial address who initiate MultiToken deploy")),(0,l.kt)("p",null,"You must emit ",(0,l.kt)("inlineCode",{parentName:"p"},"MultiTokenCreated")," event when MultiToken is minted (initial MultiToken wallet deployed)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    event MultiTokenBurned(uint256 id, uint128 count, address owner);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - Unique Nft id"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"count")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - Number of burned tokens"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"owner")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Address of MultiToken owner")),(0,l.kt)("p",null,"You must emit ",(0,l.kt)("inlineCode",{parentName:"p"},"MultiTokenBurned")," event when MultiTokens are burned."),(0,l.kt)("h4",{id:"mint-and-burn-nft-and-multitokens"},"Mint and burn NFT and MultiTokens"),(0,l.kt)("p",null,"A function's signature is not included in the specification.\nIt's recommended to return the id of the minted MultiToken in the mint function in order to find minted MultiToken wallet contracts."),(0,l.kt)("p",null,"See the Events for your responsibilities when creating MultiTokens."),(0,l.kt)("h3",{id:"nft"},"NFT"),(0,l.kt)("p",null,"When the supply is just one, the MultiToken is essentially a non-fungible token (NFT). And as is standard for ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1"},"TIP-4.1"),". Since VEP-1155 collection supports ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1/#collection"},"TIP4_1Collection")," interface, it's compatible and there is no any difference with ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1"},"TIP-4.1")," standard when dealing with NFT.\nIn order to be consistent ",(0,l.kt)("inlineCode",{parentName:"p"},"NFT")," contract must support ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1"},"TIP-4.1"),", ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/2"},"TIP-4.2")," and ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," standards completely."),(0,l.kt)("p",null,"Every VEP-1155 compliant nft contract must also implement ",(0,l.kt)("inlineCode",{parentName:"p"},"IMultiTokenNft"),". In the case that supply is just one, but no tokens, ",(0,l.kt)("inlineCode",{parentName:"p"},"multiTokenSupply()")," should return ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,l.kt)("p",null,"In the case that ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," == 1, this does not necessarily signify that the sole token owner is the ",(0,l.kt)("inlineCode",{parentName:"p"},"manager")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"owner")," of the nft through the ",(0,l.kt)("inlineCode",{parentName:"p"},"TIP4.1")," interface, only that he is the sole token owner."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IMultiTokenNft {\n    /// @notice Count total MultiToken supply\n    /// @return count A count of active MultiTokens minted by collection\n    function multiTokenSupply() external view responsible returns (uint128 count);\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NOTE")," The ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-6/1"},"TIP-6.1")," identifier for this interface is ",(0,l.kt)("inlineCode",{parentName:"p"},"0x243CF87E"),"."),(0,l.kt)("h4",{id:"imultitokennftmultitokensupply"},"IMultiTokenNft.multiTokenSupply()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function multiTokenSupply() external view responsible returns (uint128 count);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"count")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - A count of active MultiTokens minted to this nft")),(0,l.kt)("h3",{id:"multitoken-wallet"},"MultiToken Wallet"),(0,l.kt)("p",null,"The contract represents information about current MultiToken and control logic."),(0,l.kt)("p",null,"MultiToken wallet must:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"implement ",(0,l.kt)("inlineCode",{parentName:"li"},"IMultiTokenWallet")," interface and ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-6/1"},"TIP-6.1")," interfaces."),(0,l.kt)("li",{parentName:"ul"},"implement ",(0,l.kt)("inlineCode",{parentName:"li"},"TIP4_3NFT")," interface from ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," standard."),(0,l.kt)("li",{parentName:"ul"},"deploy three ",(0,l.kt)("inlineCode",{parentName:"li"},"Index")," contracts ",(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3"),' with stamp = "fungible" and different code salt:',(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"With zero collection address ",(0,l.kt)("inlineCode",{parentName:"li"},'collection = "0:0000000000000000000000000000000000000000000000000000000000000000"')," in ",(0,l.kt)("strong",{parentName:"li"},"code salt"),"."),(0,l.kt)("li",{parentName:"ul"},"With non-zero collection address ",(0,l.kt)("inlineCode",{parentName:"li"},'collection = "0:3bd8\u2026"')," ",(0,l.kt)("strong",{parentName:"li"},"in code salt"),"."))),(0,l.kt)("li",{parentName:"ul"},"implement ",(0,l.kt)("inlineCode",{parentName:"li"},"IDestroyable")," interface, the owner must decide whether to destroy the MultiToken wallet contract or not if the balance is zero."),(0,l.kt)("li",{parentName:"ul"},"destruct Index before MultiToken wallet is destroyed."),(0,l.kt)("li",{parentName:"ul"},"have correct ",(0,l.kt)("strong",{parentName:"li"},"codesalt")," with (in order):",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the collection address: ",(0,l.kt)("inlineCode",{parentName:"li"},"address collection")),(0,l.kt)("li",{parentName:"ul"},"the token id: ",(0,l.kt)("inlineCode",{parentName:"li"},"uint128 id")),(0,l.kt)("li",{parentName:"ul"},"the balance empty flag ",(0,l.kt)("inlineCode",{parentName:"li"},"bool isEmpty")),(0,l.kt)("li",{parentName:"ul"},"On a zero balance, ",(0,l.kt)("inlineCode",{parentName:"li"},"isEmpty")," must be set to ",(0,l.kt)("inlineCode",{parentName:"li"},"true")),(0,l.kt)("li",{parentName:"ul"},"On a non-zero balance, ",(0,l.kt)("inlineCode",{parentName:"li"},"isEmpty")," must be set to ",(0,l.kt)("inlineCode",{parentName:"li"},"false"))))),(0,l.kt)("p",null,"Every VEP-1155 compliant token contract must implement the IMultiTokenWallet interface and TIP-6.1 interfaces."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    pragma ton-solidity >= 0.58.0;\n\n    interface IMultiTokenWallet {\n\n        /// @notice The event emits when MultiToken is created\n        /// @dev Emit the event when MultiToken is ready to use\n        /// @param id Unique MultiToken id\n        /// @param owner Address of MultiToken owner\n        /// @param collection Address of collection smart contract that mint the MultiToken\n        /// @param balance count of minted tokens\n        event MultiTokenWalletCreated(uint256 id, address owner, address collection, uint128 balance);\n\n        /// @notice The event emits when MultiToken is transfered\n        /// @dev Emit the event when token is ready to use\n        /// @param sender MultiToken wallet owner address that sends MultiTokens\n        /// @param senderWallet Sender MultiToken wallet address\n        /// @param recipient Address of owner of recipient MultiToken wallet contract\n        /// @param count How many MultiTokens transfered\n        /// @param newBalance Recipient wallet balance after transfer\n        event MultiTokenTransfered(address sender, address senderWallet, address recipient, uint128 count, uint128 newBalance);\n\n        /// @notice MultiToken info\n        /// @return id Unique MultiToken id\n        /// @return owner Address of wallet owner\n        /// @return collection \u0421ollection smart contract address\n        function getInfo() external view responsible returns(uint256 id, address owner, address collection);\n\n        /// @notice Returns the number of owned MultiTokens\n        /// @return value owned MultiTokens count\n        function balance() external view responsible returns (uint128 value);\n        /// @notice Transfer MultiTokens to the recipient\n        /// @dev Can be called only by MultiToken owner\n        /// @param count How many MultiTokens to transfer\n        /// @param recipient Address of owner of recipient MultiToken wallet contract\n        /// @param deployTokenWalletValue How much Venom send to MultiToken wallet contract on deployment. Do not deploy contract if zero.\n        /// @param remainingGasTo Remaining gas receiver\n        /// @param notify Notify receiver on incoming transfer\n        /// @param payload Notification payload\n        function transfer(uint128 count, address recipient, uint128 deployTokenWalletValue, address remainingGasTo, bool notify, TvmCell payload) external;\n\n        /// @notice Transfer MultiTokens to the MultiToken wallet contract\n        /// @dev Can be called only by MultiToken owner\n        /// @param count How many MultiTokens to transfer\n        /// @param recipientToken Recipient MultiToken wallet contract address\n        /// @param remainingGasTo Remaining gas receiver\n        /// @param notify Notify receiver on incoming transfer\n        /// @param payload Notification payload\n        function transferToWallet(uint128 count, address recipientToken, address remainingGasTo, bool notify, TvmCell payload) external;\n\n        /// @notice Callback for transfer operation\n        /// @dev Can be called only by another valid MultiToken wallet contract with same id and collection\n        /// @param count How many MultiTokens to receiver\n        /// @param sender MultiToken wallet owner address that sends MultiTokens\n        /// @param remainingGasTo Remaining gas receiver\n        /// @param notify Notify receiver on incoming transfer\n        /// @param payload Notification payload\n        function acceptTransfer(uint128 count, address sender, address remainingGasTo, bool notify, TvmCell payload) external;\n\n        /// @notice Burn MultiTokens by owner\n        /// @dev Can be called only by MultiToken owner\n        /// @param count How many MultiTokens to burn\n        /// @param remainingGasTo Remaining gas receiver\n        /// @param callbackTo Burn callback address\n        /// @param payload Notification payload\n        function burn(uint128 count, address remainingGasTo, address callbackTo, TvmCell payload) external;\n    }\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NOTE")," The ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-6/1"},"TIP-6.1")," identifier for this interface is ",(0,l.kt)("inlineCode",{parentName:"p"},"0x2F202802"),"."),(0,l.kt)("h4",{id:"imultitokenwalletgetinfo"},"IMultiTokenWallet.getInfo()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function getInfo() external view responsible returns(uint256 id, address owner, address collection);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - Unique MultiToken id"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"owner")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - The owner of the MultiToken"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"collection")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - The MultiToken collection address")),(0,l.kt)("h4",{id:"imultitokenwalletbalance"},"IMultiTokenWallet.balance()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function balance() public view responsible returns (uint128 value);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - How many MultiTokens owned")),(0,l.kt)("h4",{id:"imultitokenwallettransfer"},"IMultiTokenWallet.transfer()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function transfer(uint128 count, address recipient, uint128 deployTokenValue, address remainingGasTo, bool notify, TvmCell payload) external;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"count")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") -  How many MultiTokens to transfer"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"recipient")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Address of owner of recipient MultiToken wallet contract"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"deployTokenWalletValue")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - How much Venom send to MultiToken wallet contract on deployment"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"remainingGasTo")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Remaining gas receiver"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"notify")," (",(0,l.kt)("inlineCode",{parentName:"li"},"bool"),") - Notify receiver on incoming transfer"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"payload")," (",(0,l.kt)("inlineCode",{parentName:"li"},"TvmCell"),") - Notification payload")),(0,l.kt)("p",null,"Transfers the number of MultiTokens to the MultiToken wallet contract, owned by recipient. MultiToken wallet contract address is derived automatically.\nIf deployTokenValue is greater than 0, MultiToken wallet contract MUST be deployed for the recipient.\nCalls the ",(0,l.kt)("inlineCode",{parentName:"p"},"acceptTransfer")," on the recipient MultiToken wallet. If notify is true, than the ",(0,l.kt)("inlineCode",{parentName:"p"},"onAcceptTokensTransfer")," callback message will be sent to the recipient.\nDecreases the MultiToken balance by count."),(0,l.kt)("h4",{id:"imultitokenwallettransfertowallet"},"IMultiTokenWallet.transferToWallet()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function transferToWallet(uint128 count, address recipientToken, address remainingGasTo, bool notify, TvmCell payload) external;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"count")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - How many MultiTokens to transfer"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"recipientToken")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Recipient MultiToken wallet contract address"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"remainingGasTo")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Remaining gas receiver"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"notify")," (",(0,l.kt)("inlineCode",{parentName:"li"},"bool"),") - Notify receiver on incoming transfer"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"payload")," (",(0,l.kt)("inlineCode",{parentName:"li"},"TvmCell"),") - Notification payload")),(0,l.kt)("p",null,"Transfers the number of MultiTokens to the MultiToken wallet contract, owned by recipient.\nCalls the ",(0,l.kt)("inlineCode",{parentName:"p"},"acceptTransfer")," on the recipient MultiToken wallet. If notify is true, than the ",(0,l.kt)("inlineCode",{parentName:"p"},"onAcceptTokensTransfer")," callback message will be sent to the recipient.\nDecreases the MultiToken balance by count."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function acceptTransfer(uint128 count, address sender, address remainingGasTo, bool notify, TvmCell payload) external;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"count")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - How many MultiTokens to transfer"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sender"),"(",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - MultiToken wallet owner address that sends MultiTokens"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"remainingGasTo")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Remaining gas receiver"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"notify ("),"bool`) - Notify receiver on incoming transfer"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"payload")," (",(0,l.kt)("inlineCode",{parentName:"li"},"TvmCell"),") - Notification payload")),(0,l.kt)("p",null,"Accepts incoming transfer for ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," of MultiTokens from MultiTokens wallet, owned by ",(0,l.kt)("inlineCode",{parentName:"p"},"sender"),".\nUpdates transfered number of MultiTokens in the MultiToken wallet contract.\ntransfer and transferToWallet must call acceptTransfer."),(0,l.kt)("h4",{id:"imultitokenwalletburn"},"IMultiTokenWallet.burn()"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    function burn(uint128 count, address remainingGasTo, address callbackTo, TvmCell payload) external;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"count")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - How many MultiTokens to burn"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"remainingGasTo")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Remaining gas receiver"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"callbackTo")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Burn callback address"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"payload")," (",(0,l.kt)("inlineCode",{parentName:"li"},"TvmCell"),") - Notification payload")),(0,l.kt)("p",null,"The MultiToken wallet must send an internal message to collection contract before MultiToken burned.\nIf callbackTo is zero address, than all the remaining gas is transferred to the remainingGasTo. Otherwise, message with ",(0,l.kt)("inlineCode",{parentName:"p"},"onAcceptTokensBurn")," callback is sent to the callbackTo address."),(0,l.kt)("h4",{id:"events-1"},"Events"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    event MultiTokenWalletCreated(uint256 id, address owner, address collection, uint128 balance);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint256"),") - Unique  MultiToken id"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"owner")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Address of MultiToken owner"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"collection")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - The collection address that initiate MultiToken deploy"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"balance")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - Initial balance")),(0,l.kt)("p",null,"You must emit ",(0,l.kt)("inlineCode",{parentName:"p"},"MultiTokenWalletCreated")," event, when MultiToken wallet created, initialized and ready to use."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"    event event MultiTokenTransfered(address senderWallet, address sender, address recipient, uint128 count, uint128 newBalance);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sender")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - MultiToken wallet owner address that sends MultiTokens"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"senderWallet")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Sender MultiToken wallet address"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"recipient")," (",(0,l.kt)("inlineCode",{parentName:"li"},"address"),") - Address of owner of recipient MultiToken wallet contract"),(0,l.kt)("li",{parentName:"ul"},"count (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - How many MultiTokens transfered"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"newBalance")," (",(0,l.kt)("inlineCode",{parentName:"li"},"uint128"),") - Recipient wallet balance after transfer")),(0,l.kt)("p",null,"You must emit ",(0,l.kt)("inlineCode",{parentName:"p"},"MultiTokenTransfered")," event, when MultiTokens transfered from one wallet to another (acceptTransfer method implementaion)."),(0,l.kt)("h4",{id:"mint-multitokenwallet"},"Mint MultiTokenWallet"),(0,l.kt)("p",null,"A function and constructor signature is not included in the specification."),(0,l.kt)("p",null,"MultiTokenWallet must be deployed from the MultiToken collection smart contract."),(0,l.kt)("p",null,"The MultiTokenWallet must emit the ",(0,l.kt)("inlineCode",{parentName:"p"},"MultiTokenWalletCreated")," event after MultiTokenWallet has been deployed and is ready to use.\nIt must be possible to specify whever to notify MultiToken owner or not. In order to be notified the owner contract must implement onAcceptTokensMint."),(0,l.kt)("h3",{id:"callbacks"},"Callbacks"),(0,l.kt)("h4",{id:"mint-callback"},"Mint callback"),(0,l.kt)("p",null,"Notifies MultiToken wallet owner that token minted."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IMultiTokenMintCallback {\n    /// @notice Callback from MultiToken wallet contract on mint initial MultiToken\n    /// @param collection Address of collection smart contract that mint MultiToken\n    /// @param tokenId Unique MultiToken id\n    /// @param count minted MultiTokens count\n    /// @param remainingGasTo Address specified for receive remaining gas\n    /// @param payload Additional data attached to transfer by sender\n    function onMintMultiToken(\n        address collection,\n        uint256 tokenId,\n        uint128 count,\n        address remainingGasTo,\n        TvmCell payload\n    ) external;\n}\n")),(0,l.kt)("h4",{id:"incoming-transfer-callback"},"Incoming transfer callback"),(0,l.kt)("p",null,"Notifies MultiToken wallet owner that the incoming transfer has been accepted."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IMultiTokenTransferCallback {\n\n    /// @notice Callback from MultiToken wallet contract on receive MultiTokens transfer\n    /// @param collection Address of collection smart contract that mint MultiToken\n    /// @param tokenId Unique MultiToken id\n    /// @param count Received MultiTokens count\n    /// @param sender MultiToken wallet owner address that sends MultiTokens\n    /// @param senderWallet Sender MultiToken wallet address\n    /// @param remainingGasTo Address specified for receive remaining gas\n    /// @param payload Additional data attached to transfer by sender        \n    function onMultiTokenTransfer(\n        address collection,\n        uint256 tokenId,\n        uint128 count,\n        address sender,\n        address senderWallet,\n        address remainingGasTo,\n        TvmCell payload\n    ) external;\n}\n")),(0,l.kt)("h3",{id:"bounced-transfer-callback"},"Bounced transfer callback"),(0,l.kt)("p",null,"Notifies MultiToken wallet owner that token transfer was bounced."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IMultiTokenBounceTransferCallback {\n\n    /// @notice Callback from TokenWallet when tokens transfer reverted\n    /// @param collection Collection of received tokens\n    /// @param tokenId Unique token id\n    /// @param count Reverted tokens count\n    /// @param revertedFrom Address which declained acceptTransfer\n    function onMultiTokenBounceTransfer(\n        address collection,\n        uint256 tokenId,\n        uint128 count,\n        address revertedFrom\n    ) external;\n}\n")),(0,l.kt)("h4",{id:"burn-callback"},"Burn callback"),(0,l.kt)("p",null,"Smart contract that processes burn callback message must implement."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IMultiTokenBurnCallback {\n\n    /// @notice Callback from MultiToken wallet contract on burn tokens\n    /// @param collection Address of collection smart contract that mint MultiToken\n    /// @param tokenId Unique MultiToken id\n    /// @param count Burned MultiTokens count\n    /// @param token Address of MultiToken wallet contract that burns tokens\n    /// @param remainingGasTo Address specified for receive remaining gas\n    /// @param payload Additional data attached to transfer by sender        \n    function onMultiTokenBurn(\n        address collection,\n        uint256 tokenId,\n        uint128 count,\n        address owner,\n        address token,\n        address remainingGasTo,\n        TvmCell payload\n    ) external;\n}\n")),(0,l.kt)("h4",{id:"idestroyable"},"IDestroyable"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IDestroyable {\n    /// @notice Destruct MultiToken and indexes\n    /// @param remainingGasTo Address specified for receive remaining gas\n    function destroy(address remainingGasTo) external;\n}    \n")),(0,l.kt)("h2",{id:"rationale"},"Rationale"),(0,l.kt)("h3",{id:"metadata-choices"},"Metadata Choices"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"symbol()")," function (found in the ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-3/core-description"},"TIP-3")," standard) was not included as we do not believe this is a globally useful piece of data to identify a generic virtual item / asset and are also prone to collisions. Short-hand symbols are used in tickers and currency trading, but they aren\u2019t as useful outside of that space."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"name()")," function (for human-readable asset names, on-chain) was removed from the standard"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"decimals()")," function was removed from the standard since the user can't own only fraction of an nft. In practice, we can only set it to zero. There is not need to return obvious value."),(0,l.kt)("h3",{id:"multitokenwallet-destroy"},"MultiTokenWallet destroy"),(0,l.kt)("p",null,"It's possible to destroy MultiTokenWallet or/and indexes contracts when balance is zero. However it results in excessive complexity and additional Venom expenses. We can't handle onBounce if contract is destroyed during transfer. Therefore we need some mechnism to singal back that transfer is completed successfully. This will add no only complexity but additional fee. Besides there are many cases where zero balance is temporary (for example put on sale and cancel sale). As a result it makes sense to have an optional destroy and declare that the owner should decide whether destroy is needed or not."),(0,l.kt)("h3",{id:"reuse-interface-from-tip-43"},"Reuse interface from ",(0,l.kt)("a",{parentName:"h3",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"TIP4_3NFT")," interface from ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," standard is for MultiTokenWallet. This interface can be used as is and cover needed functinality."),(0,l.kt)("h3",{id:"indexes"},"Indexes"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Index")," contracts from ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3"),' can help us to find MultiTokenWallet contracts as well as NFT. However they are not completely interchangeable. In order to find MultiTokenWallet only stamp is changed from "nft" to "fungible".'),(0,l.kt)("h2",{id:"visualization"},"Visualization"),(0,l.kt)("h3",{id:"legend"},"Legend"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Legend",src:t(3186).Z,width:"132",height:"349"})),(0,l.kt)("h3",{id:"example-1-put-on-sell-by-tip-3-tokens"},"Example 1: Put on sell by ",(0,l.kt)("a",{parentName:"h3",href:"https://docs.venom.foundation/standards/TIP/TIP-3/core-description"},"TIP-3")," tokens"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Put on sell by TIP-3 tokens",src:t(6122).Z,width:"3005",height:"2102"})),(0,l.kt)("h3",{id:"example-2-buy-by-tip-3-tokens"},"Example 2: Buy by ",(0,l.kt)("a",{parentName:"h3",href:"https://docs.venom.foundation/standards/TIP/TIP-3/core-description"},"TIP-3")," tokens"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Buy by TIP-3 tokens",src:t(6372).Z,width:"2344",height:"2159"})),(0,l.kt)("h2",{id:"backwards-compatibility"},"Backwards compatibility"),(0,l.kt)("p",null,"This standard is compatible with ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1"},"TIP-4.1"),", ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/2"},"TIP-4.2"),", ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")," standards."),(0,l.kt)("h2",{id:"security-considerations"},"Security considerations"),(0,l.kt)("p",null,"There are no security considerations related directly to the implementation of this standard."),(0,l.kt)("h2",{id:"copyright"},"Copyright"),(0,l.kt)("p",null,"Copyright and related rights waived via ",(0,l.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/LICENSE/"},"CC0"),"."),(0,l.kt)("h2",{id:"references"},"References"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-3/core-description"},"TIP-3")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/1"},"TIP-4.1")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/2"},"TIP-4.2")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3"},"TIP-4.3")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-6/1"},"TIP-6.1")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1155"},"Ethereum EIP-1155")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/Numiverse/VEP-1155"},"Reference implementation by N\xfcmi"))))}c.isMDXComponent=!0},6372:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/buy-a532989451093d4b141e3312adcf7a41.png"},3186:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/legend-6416a978aa8c922a8a28a859526e3a7c.svg"},6122:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/putonsell-a2bc2c69f8484a39fb02b72daf339bc0.png"}}]);