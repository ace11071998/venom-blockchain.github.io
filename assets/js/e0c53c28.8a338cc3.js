"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[5386],{4137:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(n),m=o,p=d["".concat(c,".").concat(m)]||d[m]||h[m]||r;return n?a.createElement(p,s(s({ref:t},u),{},{components:n})):a.createElement(p,s({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2823:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=n(7462),o=(n(7294),n(4137));const r={sidebar_position:1,sidebar_label:"Comparing Ethereum vs. Venom architectures"},s="Comparing Ethereum vs. Venom architectures",i={unversionedId:"build/development-guides/comparing-of-ethereum-vs-venom-architectures",id:"build/development-guides/comparing-of-ethereum-vs-venom-architectures",title:"Comparing Ethereum vs. Venom architectures",description:"Most likely, you are familiar with EVM-based blockchains like Ethereum, and you need to migrate your experience from EVM-based blockchain to Venom. This article touches most important things about the difference between the two networks.",source:"@site/docs/build/development-guides/comparing-of-ethereum-vs-venom-architectures.md",sourceDirName:"build/development-guides",slug:"/build/development-guides/comparing-of-ethereum-vs-venom-architectures",permalink:"/build/development-guides/comparing-of-ethereum-vs-venom-architectures",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Comparing Ethereum vs. Venom architectures"},sidebar:"buildSidebar",previous:{title:"Welcome",permalink:"/build/development-guides/"},next:{title:"Setting Up The Venom Smart Contract Development Environment",permalink:"/build/development-guides/setting-up-the-venom-smart-contract-development-environment"}},c={},l=[{value:"EVM as the &quot;Global Computer&quot; vs. TVM with the Dynamic Sharding protocol",id:"evm-as-the-global-computer-vs-tvm-with-the-dynamic-sharding-protocol",level:2},{value:"Synchronous vs. Asynchronous Communication",id:"synchronous-vs-asynchronous-communication",level:2},{value:"Gas Model and Fees",id:"gas-model-and-fees",level:2},{value:"Smart Contract Languages",id:"smart-contract-languages",level:2},{value:"References",id:"references",level:2}],u={toc:l};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"comparing-ethereum-vs-venom-architectures"},"Comparing Ethereum vs. Venom architectures"),(0,o.kt)("p",null,"Most likely, you are familiar with EVM-based blockchains like Ethereum, and you need to migrate your experience from EVM-based blockchain to Venom. This article touches most important things about the difference between the two networks."),(0,o.kt)("h2",{id:"evm-as-the-global-computer-vs-tvm-with-the-dynamic-sharding-protocol"},'EVM as the "Global Computer" vs. TVM with the Dynamic Sharding protocol'),(0,o.kt)("p",null,"First, let's see why the world needed a different virtual machine than EVM."),(0,o.kt)("p",null,"A blockchain virtual machine works like a distributed state machine. A state, which can change from block to block according to a pre-defined set of rules, and which can execute arbitrary machine code. The VM defines the specific rules of changing state from block to block."),(0,o.kt)("p",null,'EVM is designed like a "global computer," but only one computer for everything in the world, and the world is competing for its computing resource. Any EVM-based network inherits concurrency challenges. When validators need to reconstruct the current state, each validator must re-execute every call to every account and smart contract in sequential, one-at-a-time order. We have very expensive computing, even for simple tasks like a swap or a transfer token. Because a transaction of token transfer competes with a transaction to mint NFT and all other transactions that were sent to the network simultaneously.'),(0,o.kt)("p",null,"In the real world, we have many computers with modern multicore architectures for different tasks. You can email your friend while your computer compiles the code and does many other things."),(0,o.kt)("p",null,"The Venom blockchain works like a multicore system instead of an EVM-based network. TVM is designed as a distributed computing system with the scalability opportunity through dynamic sharding. This means that The Venom blockchain can share tasks between groups of validator nodes called \"a validator task group\" (similar to processor cores) depending on the load. The part of tasks doesn't need to wait for other tasks to be completed. For this reason, all interactions between system participants (accounts, aka smart contracts) are asynchronous. One participant doesn't need to wait for another."),(0,o.kt)("p",null,"To learn more about the architecture of the Venom blockchain, please follow ",(0,o.kt)("a",{parentName:"p",href:"/learn/architecture"},"the link")," provided."),(0,o.kt)("h2",{id:"synchronous-vs-asynchronous-communication"},"Synchronous vs. Asynchronous Communication"),(0,o.kt)("p",null,'Therefore, an important difference between TVM-based and EVM-based networks is the communication between accounts (smart contracts). An EVM-based network transaction is an atomic unit, and all transactions are executed individually and serially (atomically) by the validator when constructing a block. When one contract calls another, it means one continuous process executing bytecode with the state of all accounts. Therefore, each next transaction relies on the completion of the previous one, and regardless they are accessing the same account state or not. This way of executing transactions is synchronous; all transactions are processed in "the main program flow."'),(0,o.kt)("p",null,"TVM, by design, has an asynchronous communication model between accounts (aka smart contracts). This is because of the need to maintain calls between contracts in different shards processed by different validator task groups. In this way, each account has the only way to affect the state of some other account by sending a message. When an account receives an inbound message, it triggers the computation of the account's new state and the possibility of generating one or more outbound messages, with the account serving as the source. The inbound message and the previous state of the account serve as inputs for the transaction, while the generated outbound messages and the next state of the account serve as outputs."),(0,o.kt)("p",null,"This makes the transaction processing in TVM more efficient because it is not necessary to update the state of all accounts when executing each transaction. Instead, each account processes only the messages that are addressed to it, allowing for the parallel processing of multiple transactions and increasing the transaction processing speed."),(0,o.kt)("p",null,"You can find additional information regarding messages and transactions by clicking on the following link ",(0,o.kt)("a",{parentName:"p",href:"/learn/messages-and-transactions"},"here"),"."),(0,o.kt)("h2",{id:"gas-model-and-fees"},"Gas Model and Fees"),(0,o.kt)("p",null,"In Ethereum, the gas model is used to limit the number of computational steps that a transaction can perform. Users pay gas fees for each transaction they send, and these fees are paid in the native currency of the network, Ether (ETH). The fees are determined by the amount of gas used by a transaction, and the gas price, which fluctuates according to network demand."),(0,o.kt)("p",null,"On the other hand, in Venom, the fee calculation is based on a combination of gas, data storage, and forward message fees. The user decides how many VENOM to attach as payment fees from their contract account for the call, and this value is the upper limit for the cost of executing the call chain for the user."),(0,o.kt)("p",null,"By including data storage fees in the fee calculation, Venom incentivizes efficient use of storage space on the network and encourages developers to design contracts that minimize storage usage. This helps to prevent network congestion in the long term."),(0,o.kt)("p",null,"Additional information regarding gas and fees can be found ",(0,o.kt)("a",{parentName:"p",href:"/learn/transaction-fees"},"here"),"."),(0,o.kt)("h2",{id:"smart-contract-languages"},"Smart Contract Languages"),(0,o.kt)("p",null,"Ethereum primarily uses Solidity as its smart contract language. Solidity is a statically-typed, contract-oriented programming language designed specifically for writing smart contracts on the Ethereum platform. It has gained widespread adoption due to its ease of use and familiarity for developers coming from other programming languages."),(0,o.kt)("p",null,"T-Sol (Threaded-Solidity) is a high-level programming language designed explicitly for the TVM Actor Model utilized by the Venom blockchain. It provides built-in support for callbacks, fee management, managing actor states, message passing, and state isolation, all of which are critical features for the TVM platform's efficient and secure operation. As a language with the same syntax as Solidity, T-Sol is easy to use and understand for developers already familiar with Solidity."),(0,o.kt)("p",null,"TVM, however, does not rely on a single, smart contract language. The Threaded Virtual Machine (TVM) is designed to be language-agnostic, allowing developers to write smart contracts in multiple languages."),(0,o.kt)("p",null,"The Standards ",(0,o.kt)("a",{parentName:"p",href:"/standards/VEP/"},"section")," contains specifications of smart contract architectures that are specifically designed for the TVM asynchronous model."),(0,o.kt)("h2",{id:"references"},"References"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/API.md"},"T-Sol API"))))}h.isMDXComponent=!0}}]);