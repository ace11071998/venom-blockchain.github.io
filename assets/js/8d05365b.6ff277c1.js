"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[2825],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>p});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=a.createContext({}),c=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(i.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(t),p=o,g=m["".concat(i,".").concat(p)]||m[p]||d[p]||r;return t?a.createElement(g,l(l({ref:n},u),{},{components:t})):a.createElement(g,l({ref:n},u))}));function p(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,l=new Array(r);l[0]=m;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:o,l[1]=s;for(var c=2;c<r;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3626:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(7462),o=(t(7294),t(3905));const r={sidebar_position:0,sidebar_label:"Voting system contracts",description:"This section will show you how to create your own SMV simple system. The real purpose of this guide - to explore some common mechanics like address calculation, external callings and bounce handling."},l="Venom In Action. Voting system contracts",s={unversionedId:"build/development-guides/developing-of-simple-voting-system/venom-in-action/voting-system-contracts",id:"build/development-guides/developing-of-simple-voting-system/venom-in-action/voting-system-contracts",title:"Venom In Action. Voting system contracts",description:"This section will show you how to create your own SMV simple system. The real purpose of this guide - to explore some common mechanics like address calculation, external callings and bounce handling.",source:"@site/docs/build/00-development-guides/04-developing-of-simple-voting-system/01-venom-in-action/00-voting-system-contracts.md",sourceDirName:"build/00-development-guides/04-developing-of-simple-voting-system/01-venom-in-action",slug:"/build/development-guides/developing-of-simple-voting-system/venom-in-action/voting-system-contracts",permalink:"/build/development-guides/developing-of-simple-voting-system/venom-in-action/voting-system-contracts",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,sidebar_label:"Voting system contracts",description:"This section will show you how to create your own SMV simple system. The real purpose of this guide - to explore some common mechanics like address calculation, external callings and bounce handling."},sidebar:"buildSidebar",previous:{title:"Voting system basics",permalink:"/build/development-guides/developing-of-simple-voting-system/voting-system-basics"},next:{title:"Ways of code enhancing",permalink:"/build/development-guides/developing-of-simple-voting-system/venom-in-action/ways-of-code-enhancing"}},i={},c=[],u={toc:c};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"venom-in-action-voting-system-contracts"},"Venom In Action. Voting system contracts"),(0,o.kt)("p",null,"No further ado. Let's start with familiar command"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"npx locklift init --path my-smv\n")),(0,o.kt)("p",null,"As you previously read, we need to implement two smart contracts. There is no external dependencies for this guide. Start with ",(0,o.kt)("inlineCode",{parentName:"p"},"Vote")," contract. We have a pretty clean state and constructor without something unusual"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Vote.sol" lineNumbers="true"',title:'"Vote.sol"',lineNumbers:'"true"'},'pragma ever-solidity >= 0.61.2;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "./Ballot.sol";\n\ncontract Vote {\n    uint16  static _nonce;\n    TvmCell static _ballotCode;\n\n    uint256 _managerPublicKey;\n    uint32  _acceptedCount;\n    uint32  _rejectedCount;\n\n    constructor(\n        uint256 managerPublicKey,\n        address sendRemainingGasTo\n    ) public {\n        tvm.accept();\n        tvm.rawReserve(0.1 ever, 0);\n        _managerPublicKey = managerPublicKey;\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n}\n')),(0,o.kt)("p",null,"Next function we need - ",(0,o.kt)("inlineCode",{parentName:"p"},"deployBallot"),'. It realize popular "deploy contract from contract" mechanic well-descripted ',(0,o.kt)("a",{parentName:"p",href:"https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/API.md#deploy-contract-from-contract"},"here"),". We should just use ",(0,o.kt)("inlineCode",{parentName:"p"},"tvm.buildStateInit")," function, fill ",(0,o.kt)("inlineCode",{parentName:"p"},"varInit")," section by future values of our ",(0,o.kt)("inlineCode",{parentName:"p"},"Ballot")," contract static variables and use keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," for deploying."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Vote.sol" lineNumbers="true"',title:'"Vote.sol"',lineNumbers:'"true"'},"pragma ever-solidity >= 0.61.2;\n...\n\ncontract Vote {\n   ...\n    function deployBallot(address owner, address sendRemainingGasTo) external view {\n        tvm.rawReserve(0.1 ever, 0);\n        TvmCell ballotStateInit = tvm.buildStateInit({\n            contr: Ballot,\n            // varInit section has an affect for target contract address calculation\n            varInit: {\n                _vote: address(this),\n                _managerPublicKey: _managerPublicKey,\n                _owner: owner\n            },\n            code: _ballotCode // we store it in state\n        });\n        new Ballot{\n            stateInit: ballotStateInit,\n            value: 0,\n            flag: 128\n        }(\n            sendRemainingGasTo\n        ); \n    }\n    ...\n}\n")),(0,o.kt)("p",null,"Well, the votes will be stored in our Vote contract. That's why we need a special function, that can be called only by Ballot contract. Ballot contract will call this function and pass a vote (accept or reject) into. But how we can define a function, that can be called only by contracts with concrete code (by contracts, that was deployed by Vote contract)?"," "),(0,o.kt)("p",null,"It can't be any easier. Address of any contract can be definitely calculated, if you know state init variables, public key and contract code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Vote.sol" lineNumbers="true"',title:'"Vote.sol"',lineNumbers:'"true"'},"pragma ever-solidity >= 0.61.2;\n...\n\ncontract Vote {\n    ...\n    // this function will be called by ballots, but how we can know - is calling ballot a fake or not?\n    function onBallotUsed(address owner, address sendRemainingGasTo, bool accept) external {\n        tvm.rawReserve(0.1 ever, 0);\n        // if you know init params of contract you can pretty simple calculate it's address\n        TvmCell ballotStateInit = tvm.buildStateInit({\n            contr: Ballot,\n            varInit: {\n                _vote: address(this),\n                _managerPublicKey: _managerPublicKey,\n                _owner: owner\n            },\n            code: _ballotCode\n        });\n        // so address is a hash from state init\n        address expectedAddress = address(tvm.hash(ballotStateInit));\n        // and now we can just compare msg.sender address with calculated expected address\n        // if its equals - calling ballot has the same code, that Vote stores and deploys\n        if (msg.sender == expectedAddress) {\n            if (accept) {\n                _acceptedCount++;\n            } else {\n                _rejectedCount++;\n            }\n            sendRemainingGasTo.transfer({value: 0, flag: 128, bounce: false});\n        } else {\n            msg.sender.transfer({ value: 0, flag: 128, bounce: false });\n        }\n    }\n    ...\n}\n")),(0,o.kt)("p",null,"That is the way out! ",(0,o.kt)("inlineCode",{parentName:"p"},"TokenWallets")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"TIP-3")," implementation working the same way to transfer tokens (one wallet calls another wallet's ",(0,o.kt)("inlineCode",{parentName:"p"},"acceptTransfer")," function)."),(0,o.kt)("p",null,"The last thing we need is a getDetails view function to return results of our vote"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function getDetails() external view returns (uint32 accepted, uint32 rejected) {\n    return (_acceptedCount, _rejectedCount);\n}\n")),(0,o.kt)("p",null,"Bring it all together"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Vote.sol" lineNumbers="true"',title:'"Vote.sol"',lineNumbers:'"true"'},'pragma ever-solidity >= 0.61.2;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "./Ballot.sol";\n\ncontract Vote {\n    uint16  static _nonce;\n    TvmCell static _ballotCode;\n\n    uint256 _managerPublicKey;\n    uint32  _acceptedCount;\n    uint32  _rejectedCount;\n\n    constructor(\n        uint256 managerPublicKey,\n        address sendRemainingGasTo\n    ) public {\n        tvm.accept();\n        tvm.rawReserve(0.1 ever, 0);\n        _managerPublicKey = managerPublicKey;\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n\n    function deployBallot(address owner, address sendRemainingGasTo) external view {\n        tvm.rawReserve(0.1 ever, 0);\n        TvmCell ballotStateInit = tvm.buildStateInit({\n            contr: Ballot,\n            varInit: {\n                _vote: address(this),\n                _managerPublicKey: _managerPublicKey,\n                _owner: owner\n            },\n            code: _ballotCode\n        });\n        new Ballot{\n            stateInit: ballotStateInit,\n            value: 0,\n            flag: 128\n        }(\n            sendRemainingGasTo\n        ); \n    }\n\n    // this function will be called by ballots, but how we can know - is calling ballot a fake or not?\n    function onBallotUsed(address owner, address sendRemainingGasTo, bool accept) external {\n        tvm.rawReserve(0.1 ever, 0);\n        // if you know init params of contract you can pretty simple calculate it\'s address\n        TvmCell ballotStateInit = tvm.buildStateInit({\n            contr: Ballot,\n            varInit: {\n                _vote: address(this),\n                _managerPublicKey: _managerPublicKey,\n                _owner: owner\n            },\n            code: _ballotCode\n        });\n        // so address is a hash from state init\n        address expectedAddress = address(tvm.hash(ballotStateInit));\n        // and now we can just compare msg.sender address with calculated expected address\n        // if its equals - calling ballot has the same code, that Vote stores and deploys\n        if (msg.sender == expectedAddress) {\n            if (accept) {\n                _acceptedCount++;\n            } else {\n                _rejectedCount++;\n            }\n            sendRemainingGasTo.transfer({value: 0, flag: 128, bounce: false});\n        } else {\n            msg.sender.transfer({ value: 0, flag: 128, bounce: false });\n        }\n    }\n\n    function getDetails() external view returns (uint32 accepted, uint32 rejected) {\n        return (_acceptedCount, _rejectedCount);\n    }\n}\n')),(0,o.kt)("p",null,"Now let's deal with ",(0,o.kt)("inlineCode",{parentName:"p"},"Ballot")," contract. There is no something special in state and constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Ballot.sol" lineNumbers="true"',title:'"Ballot.sol"',lineNumbers:'"true"'},'pragma ever-solidity >= 0.61.2;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "./interfaces/IVote.sol";\n\ncontract Ballot {\n    address static _vote;\n    uint256 static _managerPublicKey;\n    // we have a static for owner...so our logic would be like "allow this address to vote"\n    // we can store a static here for ballot number, and our logic would been "allow that ballot to vote"\n    address static _owner;\n\n    bool _activated; // have ballot already been activated\n    bool _used;      // have ballot already been used (vote)\n\n    constructor(address sendRemainingGasTo) public {\n        // we are reserving another 0.1 here for paying for future external call\n        // all another reserves will be on 0.1 only\n        tvm.rawReserve(0.1 ever + 0.1 ever, 0);\n        if (msg.sender != _vote) {\n            selfdestruct(msg.sender);\n        }\n        _activated = false;\n        _used = false;\n    }\n}    \n')),(0,o.kt)("p",null,"Let's talk about activation mechanic. In constructor we already reserved little more venoms. We made it with purpose, that fee for external call will be payed from contract balance. That way of gas management allows us to transfer external calls fee paying to user responsibility. But activate method shouldn't be called by somebody unauthorized, so we just use ",(0,o.kt)("inlineCode",{parentName:"p"},"require")," keyword with comparing ",(0,o.kt)("inlineCode",{parentName:"p"},"msg.pubkey")," and  ",(0,o.kt)("inlineCode",{parentName:"p"},"_managerPublicKey")," stored in state init. Of course you need to call ",(0,o.kt)("inlineCode",{parentName:"p"},"tvm.accept()")," function. Simply put, this call allows contract to use it's own balance for execution pay."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Ballot.sol" lineNumbers="true"',title:'"Ballot.sol"',lineNumbers:'"true"'},'pragma ever-solidity >= 0.61.2;\n...\n\nimport "./interfaces/IVote.sol";\n\ncontract Ballot {\n    ...\n    // this function will be called by external message, so contract will pay for this call\n    // this mechanic exists for moving commision paying to user responsibility\n    // in consctructor we reserver a little more venoms, so here we just will use them (with returning remains)\n    // useful mechaninc for your dapp\n    function activate() external {\n        require(msg.pubkey() == _managerPublicKey, 200);\n        tvm.accept(); // allow to use contract balance for paying this function execution\n        _activated = true;\n        tvm.rawReserve(0.1 ever, 0);\n        _owner.transfer({ value: 0, flag: 128, bounce: false });\n    }\n    ...\n}\n')),(0,o.kt)("p",null,"Let's implement main function of our ",(0,o.kt)("inlineCode",{parentName:"p"},"Ballot")," - ",(0,o.kt)("inlineCode",{parentName:"p"},"vote"),"."),(0,o.kt)("p",null,"Pay attention to imports. We have ",(0,o.kt)("inlineCode",{parentName:"p"},'import "./interfaces/IVote.sol";')," . It's just an interface for calling our ",(0,o.kt)("inlineCode",{parentName:"p"},"Vote")," contract (just like for EVM if you know what I mean)."," "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="interfaces/IVote.sol" lineNumbers="true"',title:'"interfaces/IVote.sol"',lineNumbers:'"true"'},"pragma ever-solidity >= 0.61.2;\npragma AbiHeader expire;\n\ninterface IVote {\n    function onBallotUsed(address owner, address sendRemainingGasTo, bool accept) external;\n}\n")),(0,o.kt)("p",null,"Let us now return for ",(0,o.kt)("inlineCode",{parentName:"p"},"vote")," function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Ballot.sol" lineNumbers="true"',title:'"Ballot.sol"',lineNumbers:'"true"'},'pragma ever-solidity >= 0.61.2;\n...\n\nimport "./interfaces/IVote.sol";\n\ncontract Ballot {\n    ...\n    function vote(address sendRemainingGasTo, bool accept) external {\n        require(msg.sender == _owner, 201); // remember the library for error codes :)\n        require(_activated && !_used, 202);\n        tvm.rawReserve(0.1 ever, 0);\n        // just call our vote contract\n        IVote(_vote).onBallotUsed{\n            value: 0,\n            flag: 128,\n            bounce: true\n        }(_owner, sendRemainingGasTo, accept);\n        _used = true;\n    }\n    ...\n}\n')),(0,o.kt)("p",null,"That's all. ",(0,o.kt)("inlineCode",{parentName:"p"},"Vote")," contract will check our Ballot address by calculating it, as you remember, and vote will be accept. But what if Vote calls will fail because of some reason (low gas attached or yet network problem!)? Our ",(0,o.kt)("inlineCode",{parentName:"p"},"Ballot")," will be marked as used (",(0,o.kt)("inlineCode",{parentName:"p"},"_used")," state variable will be set as true, and we can't call vote once again). For solve this problems, TVM has a ",(0,o.kt)("a",{parentName:"p",href:"/learn/messages-and-transactions"},"bounce")," messages and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/API.md#onbounce"},(0,o.kt)("inlineCode",{parentName:"a"},"onBounce"))," function for handling it. Let's deal with it by example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Ballot.sol" lineNumbers="true"',title:'"Ballot.sol"',lineNumbers:'"true"'},'pragma ever-solidity >= 0.61.2;\n...\n\nimport "./interfaces/IVote.sol";\n\ncontract Ballot {\n    ...\n    // onBounce function!\n    // if our vote contract will reject message, it sends a bounce message to this callback. We should return _used flag to false!\n    onBounce(TvmSlice bounce) external {\n        uint32 functionId = bounce.decode(uint32);\n        // IVote.onBallotUsed send us a bounce message\n        if (functionId == tvm.functionId(IVote.onBallotUsed) && msg.sender == _vote) {\n            tvm.rawReserve(0.1 ever, 0);\n            _used = false; // reset _used flag to false\n        }\n    }\n    ...\n}\n')),(0,o.kt)("p",null,"That's it. Now let's bring it all together."," "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Ballot.sol" lineNumbers="true"',title:'"Ballot.sol"',lineNumbers:'"true"'},'pragma ever-solidity >= 0.61.2;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "./interfaces/IVote.sol";\n\ncontract Ballot {\n    address static _vote;\n    uint256 static _managerPublicKey;\n    // we have a static for owner...so our logic would be like "allow this address to vote"\n    // we can store a static here for ballot number, and our logic would been "allow that ballot to vote"\n    address static _owner;\n\n    bool _activated; // have ballot already been activated\n    bool _used;      // have ballot already been used (vote)\n\n    constructor(address sendRemainingGasTo) public {\n        // we are reserving another 0.1 here for paying for future external call\n        // all another reserves will be on 0.1 only\n        tvm.rawReserve(0.1 ever + 0.1 ever, 0);\n        if (msg.sender != _vote) {\n            selfdestruct(msg.sender);\n        }\n        _activated = false;\n        _used = false;\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n\n    // this function will be called by external message, so contract will pay for this call\n    // this mechanic exists for moving commision paying to user responsibility\n    // in consctructor we reserver a little more venoms, so here we just will use them (with returning remains)\n    // useful mechaninc for your dapp\n    function activate() external {\n        require(msg.pubkey() == _managerPublicKey, 200);\n        tvm.accept(); // allow to use contract balance for paying this function execution\n        _activated = true;\n        tvm.rawReserve(0.1 ever, 0);\n        _owner.transfer({ value: 0, flag: 128, bounce: false });\n    }\n\n    function vote(address sendRemainingGasTo, bool accept) external {\n        require(msg.sender == _owner, 201);\n        require(_activated && !_used, 202);\n        tvm.rawReserve(0.1 ever, 0);\n        // just call our vote contract\n        IVote(_vote).onBallotUsed{\n            value: 0,\n            flag: 128,\n            bounce: true\n        }(_owner, sendRemainingGasTo, accept);\n        _used = true;\n    }\n\n    // onBounce function!\n    // if our vote contract will reject message, it sends a bounce message to this callback. We should return _used flag to false!\n    onBounce(TvmSlice bounce) external {\n        uint32 functionId = bounce.decode(uint32);\n        // IVote.onBallotUsed send us a bounce message\n        if (functionId == tvm.functionId(IVote.onBallotUsed) && msg.sender == _vote) {\n            tvm.rawReserve(0.1 ever, 0);\n            _used = false;\n        }\n    }\n\n}\n')),(0,o.kt)("p",null,"Do not forget about tests and scripts. We won't show any scripts in this guideline just because there is no something special in. All source ode with deploy script and simple test suite are available in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/venom-blockchain/guides/tree/master/vote-contracts"},"repo"),". Next section will show you some enhancing for this code."))}d.isMDXComponent=!0}}]);