"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[2554],{4137:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=l(n),u=r,f=p["".concat(d,".").concat(u)]||p[u]||h[u]||i;return n?a.createElement(f,s(s({ref:t},c),{},{components:n})):a.createElement(f,s({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=p;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1388:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=n(7462),r=(n(7294),n(4137));const i={title:"VEP-1111: Contract indexation"},s=void 0,o={unversionedId:"standards/VEP/vep-1111",id:"standards/VEP/vep-1111",title:"VEP-1111: Contract indexation",description:"Abstract",source:"@site/docs/standards/VEP/vep-1111.md",sourceDirName:"standards/VEP",slug:"/standards/VEP/vep-1111",permalink:"/standards/VEP/vep-1111",draft:!1,tags:[],version:"current",frontMatter:{title:"VEP-1111: Contract indexation"},sidebar:"standardSidebar",previous:{title:"VEP-1: VEP Purpose and Guidelines",permalink:"/standards/VEP/vep-1"},next:{title:"VEP-1155: Multi-Token",permalink:"/standards/VEP/vep-1155"}},d={},l=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Specification",id:"specification",level:2},{value:"Contracts",id:"contracts",level:3},{value:"IndexFactory",id:"indexfactory",level:3},{value:"IIndexFactory.getIndexCode()",id:"iindexfactorygetindexcode",level:4},{value:"IIndexFactory.resolveIndexCodeHash()",id:"iindexfactoryresolveindexcodehash",level:4},{value:"IIndexFactory.deployIndex()",id:"iindexfactorydeployindex",level:4},{value:"IIndexFactory.destructIndex()",id:"iindexfactorydestructindex",level:4},{value:"Index",id:"index",level:3},{value:"Static variables",id:"static-variables",level:4},{value:"IIndex.getIndexedContract()",id:"iindexgetindexedcontract",level:4},{value:"IIndex.getIndexFactory()",id:"iindexgetindexfactory",level:4},{value:"IIndex.getCodeHash()",id:"iindexgetcodehash",level:4},{value:"IIndex.destruct()",id:"iindexdestruct",level:4},{value:"Rationale",id:"rationale",level:2},{value:"Copyright",id:"copyright",level:2},{value:"References",id:"references",level:2}],c={toc:l};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-preamble"},"VEP: 1111\nauthor: Danil Naumov <ds0r0san@proton.me>\nstatus: Draft\ntype: Contract\ncreated: 2023-07-20\n")),(0,r.kt)("h2",{id:"abstract"},"Abstract"),(0,r.kt)("p",null,"The following standard describes the on-chain smart contracts indexing and provides basic functionality to create, search and destruct indexes."),(0,r.kt)("h2",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"A common pattern in the Venom blockchain is to search for contracts with the same code by its hash. This can be useful if we want to find all contracts of the same type."),(0,r.kt)("p",null,"Furthermore, TVM includes an instruction to salt the contract code (",(0,r.kt)("inlineCode",{parentName:"p"},"tvm.setCodeSalt(code, salt)"),"). With the knowledge of both the Index contract's source code and the associated salt parameters, it becomes possible to compute the hash code off-chain. This allows for efficient filtering of all contracts that fulfill the set criteria."),(0,r.kt)("p",null,"This approach finds its application in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3/"},"TIP-4.3 [Non-Fungible Token on-chain indexes]"),"."),(0,r.kt)("p",null,"The proposition at hand aims to extend the scope of this standard to incorporate any family of contracts. By doing so, it provides a generalized standard fit for a broad range of contract families."),(0,r.kt)("h2",{id:"specification"},"Specification"),(0,r.kt)("p",null,"The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in ",(0,r.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc2119"},"RFC 2119"),"."),(0,r.kt)("h3",{id:"contracts"},"Contracts"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IndexFactory")," - Contract responsible for deploying indexes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Index")," - Contract that store the address of the indexed contract.")),(0,r.kt)("h3",{id:"indexfactory"},"IndexFactory"),(0,r.kt)("p",null,"The IndexFactory contract is responsible for handling the deployment and uniqueness enforcement of Index contracts. It stores the Index contract code and handle the code salting process, which ensures the creation of distinct instances of each Index contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma ever-solidity >=0.62.0;\n\ninterface IIndexFactory {\n  /**\n   * @notice This event emits when Index is deployed\n   * @param index Index address\n   * @param indexedContract Indexed contract address\n   * @param indexCodeHash Hash of the Index code, that can be used to find Indexes with the same parameters\n   * @param saltKey The name of the salt parameters\n   * @param saltValue Parameters of the salt packed into cell\n   */\n  event IndexDeployed(address index, address indexedContract, uint256 indexCodeHash, string saltKey, TvmCell saltValue);\n\n  /**\n   * @notice Returns the code of the Index contract\n   * @return TvmCell representing the index code of the contract\n   */\n  function getIndexCode() external view responsible returns (TvmCell);\n\n  /**\n   * @notice Calculates and returns the code hash of the Index contract based on the provided salt parameters\n   * @param saltKey The name of the salt parameters\n   * @param saltValue Parameters of the salt packed into cell\n   * @return The calculated code hash for the Index contract\n   */\n  function resolveIndexCodeHash(string saltKey, TvmCell saltValue) external view responsible returns (uint256);\n}\n")),(0,r.kt)("h4",{id:"iindexfactorygetindexcode"},"IIndexFactory.getIndexCode()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getIndexCode() external view returns (TvmCell indexCode);\n")),(0,r.kt)("p",null,"Returns the address of the owner of the contract"),(0,r.kt)("h4",{id:"iindexfactoryresolveindexcodehash"},"IIndexFactory.resolveIndexCodeHash()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function resolveIndexCodeHash(string saltKey, TvmCell saltValue) external view responsible returns (uint256);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"saltKey(",(0,r.kt)("inlineCode",{parentName:"li"},"string"),") - The name of the salt parameters"),(0,r.kt)("li",{parentName:"ul"},"saltValue(",(0,r.kt)("inlineCode",{parentName:"li"},"TvmCell"),") - Parameters used to uniqueize the hash of the contract code. It can contain any set of parameters.")),(0,r.kt)("p",null,"Calculates and returns the code hash of the Index contract based on the provided salt parameters"),(0,r.kt)("h4",{id:"iindexfactorydeployindex"},"IIndexFactory.deployIndex()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function deployIndex(address indexedContract, string saltKey, TvmCell saltValue) internal view;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"indexedContract(",(0,r.kt)("inlineCode",{parentName:"li"},"address"),") - Indexed contract address"),(0,r.kt)("li",{parentName:"ul"},"saltKey(",(0,r.kt)("inlineCode",{parentName:"li"},"string"),") - The name of the salt parameters"),(0,r.kt)("li",{parentName:"ul"},"saltValue(",(0,r.kt)("inlineCode",{parentName:"li"},"TvmCell"),") - Parameters used to uniqueize the hash of the contract code. It can contain any set of parameters.")),(0,r.kt)("p",null,"Deploys an Index contract for a specified indexed contract and salt parameters."),(0,r.kt)("p",null,"To create salt, the ",(0,r.kt)("inlineCode",{parentName:"p"},"_buildSalt")," function is used. It packs the salt parameters into a cell and returns it. This function MUST use ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexFactory")," address as the first parameter, to guarantee uniqueness of the salt between different ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexFactory")," contracts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"/**\n  * @notice Builds a TvmCell using the provided salt parameters.\n  * @param saltKey The name of the salt parameters\n  * @param saltValue Parameters of the salt packed into cell\n  * @return TvmCell built using the provided salt parameters.\n  */\nfunction _buildSalt(string saltKey, TvmCell saltValue) internal pure returns (TvmCell) {\n  TvmBuilder salt;\n  // salt with index factory address\n  salt.store(address(this));\n  // salt with salt key\n  salt.store(saltKey);\n  // salt with salt value\n  salt.store(saltValue);\n\n  return salt.toCell();\n}\n")),(0,r.kt)("h4",{id:"iindexfactorydestructindex"},"IIndexFactory.destructIndex()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"/**\n  * @notice Destroys a specified Index contract and sends its remaining gas to a specified address\n  * @param index The address of the Index contract to be destroyed\n  * @param sendGasTo The address to which the remaining gas of the Index contract will be sent\n  */\nfunction destructIndex(address index, address sendGasTo) internal view virtual {\n  Index(index).destruct{ value: _indexDestroyValue }(sendGasTo);\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"index(",(0,r.kt)("inlineCode",{parentName:"li"},"address"),") - The address of the Index contract to be destroyed"),(0,r.kt)("li",{parentName:"ul"},"sendGasTo(",(0,r.kt)("inlineCode",{parentName:"li"},"address"),") - The address to which the remaining gas of the Index contract will be sent")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"destructIndex")," function is used to destroy the Index contract. It sends the remaining gas of the Index contract to the specified address. This function MUST be overridden in the child contract to specify the value of the gas to be sent to the Index contract."),(0,r.kt)("h3",{id:"index"},"Index"),(0,r.kt)("p",null,"The Index contract is responsible for storing the address of the indexed contract. Its code hash can be restored provided the parameters used for code salting are known. Thus, by knowing these parameters, all Index contracts that satisfy these parameters can be located. Furthermore, by knowing the address of the Index contract, the address of the desired contract can be retrieved. This facilitates efficient contract management and accessibility within the blockchain environment."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"pragma ever-solidity >=0.62.0;\n\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\ninterface IIndex {\n  /**\n   * @notice Get indexed contract\n   * @return address of the indexed contract\n   */\n  function getIndexedContract() external view responsible returns (address);\n\n  /**\n   * @notice Get IndexFactory address\n   * @return address of the IndexFactory contract\n   */\n  function getIndexFactory() external view responsible returns (address);\n\n  /**\n   * @notice Get code hash\n   * @return hash of the code\n   */\n  function getCodeHash() external view responsible returns (uint256);\n\n  /**\n   * @notice Destruct the contract\n   * @param gasReceiver Address to receive leftover gas from the destructed contract\n   */\n  function destruct(address gasReceiver) external;\n}\n\n")),(0,r.kt)("h4",{id:"static-variables"},"Static variables"),(0,r.kt)("p",null,"Static variables form a part of the InitState and therefore affect the contract's address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"address static _indexedContract;\nuint256 static _saltHash;\n")),(0,r.kt)("p",null,"_indexedContract(",(0,r.kt)("inlineCode",{parentName:"p"},"address"),") - Indexed contract address.\n_saltHash(",(0,r.kt)("inlineCode",{parentName:"p"},"uint256"),") - Hash of the salt parameters used to create the Index contract. Since the salt always incorporates the IndexFactory's address, including the salt hash allows for the unique differentiation of Index contract addresses between various IndexFactory contracts."),(0,r.kt)("h4",{id:"iindexgetindexedcontract"},"IIndex.getIndexedContract()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getIndexedContract() external view returns (address);\n")),(0,r.kt)("p",null,"Returns indexed contract address"),(0,r.kt)("h4",{id:"iindexgetindexfactory"},"IIndex.getIndexFactory()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getIndexFactory() external view returns (address);\n")),(0,r.kt)("p",null,"Returns IndexFactory address"),(0,r.kt)("h4",{id:"iindexgetcodehash"},"IIndex.getCodeHash()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getCodeHash() external view returns (uint256);\n")),(0,r.kt)("p",null,"Returns Index code hash"),(0,r.kt)("h4",{id:"iindexdestruct"},"IIndex.destruct()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function destruct(address gasReceiver) external;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"sendGasTo(",(0,r.kt)("inlineCode",{parentName:"li"},"address"),") - The address to which the remaining gas of the Index contract will be sent")),(0,r.kt)("p",null,"Destroys the Index contract and sends its remaining gas to a specified address"),(0,r.kt)("h2",{id:"rationale"},"Rationale"),(0,r.kt)("p",null,"The primary rationale for this extension arises from the recurring pattern in the Venom blockchain, where contracts of the same type are frequently searched based on their shared code hash. Such an approach is often essential when identifying all instances of a specific contract type is required."),(0,r.kt)("p",null,"However, this approach becomes limited when contracts have salted codes, leading to different hash codes. But, if both the Index contract's source code and the associated salt parameters are known, it becomes possible to calculate the hash code off-chain. This capability can significantly enhance the efficiency of the search process, allowing for precise filtering of all contracts matching the set criteria. This is particularly applicable in scenarios that require a broad range of contracts to be identifiable by their common characteristics or functionalities, thus necessitating an efficient and robust filtering process."),(0,r.kt)("p",null,"Considering the above, this proposal advocates for the generalization of the TIP-4.3 ","[Non-Fungible Token on-chain indexes]"," standard. By extending the scope of this standard to accommodate any family of contracts, it paves the way for a more flexible, efficient, and generalized approach to contract identification and filtering on the Venom blockchain. The aim is to create a standard that caters to the requirements of a diverse range of contract families, thereby enhancing the overall functionality and usability of the Venom blockchain."),(0,r.kt)("h2",{id:"copyright"},"Copyright"),(0,r.kt)("p",null,"Copyright and related rights waived via ",(0,r.kt)("a",{parentName:"p",href:"https://docs.venom.foundation/standards/LICENSE/"},"CC0"),"."),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.venom.foundation/standards/TIP/TIP-4/3/"},"TIP-4.3")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/s0r0k/factory"},"Reference implementation"))))}h.isMDXComponent=!0}}]);